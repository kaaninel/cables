part of '../kablo.dart';

/// The `Aggragate` class is a stream that aggregates key-value pairs into a map.
/// It allows you to add, remove, and clear entries in the map, and provides methods to convert the map to a list or set.
class Aggragate<K, V> extends Stream<Map<K, V>>
    with
        Input<MapEntry<K, V?>>,
        Disposable,
        Output,
        OutputCounter,
        Waiter,
        InputLogger,
        Processor,
        Disposable,
        StateValue {
  Aggragate({List<LogConfig<MapEntry<K, V?>>>? loggers}) {
    if (kDebugMode && loggers != null) loggers.forEach(inputLogger);
    initOutputCounter();
    initDisposable();
    initState();
    initWaiter(initProcessor().inputSub);
  }
  @override
  Map<K, V> value = {};

  @override
  processor(input) async* {
    await for (final entry in input) {
      if (entry.value == null) {
        value.remove(entry.key);
      } else {
        value[entry.key] = entry.value as V;
      }
      yield value;
    }
  }

  /// Returns a stream of the map's values as a list.
  Stream<List<V>> asList() => output.map((event) => event.values.toList());

  /// Returns a stream of the map's values as a set.
  Stream<Set<V>> asSet() => output.map((event) => event.values.toSet());

  /// Clears the map.
  void clear() => value = {};

  /// Creates an `Aggragate` instance from a list of streams.
  static Aggragate<int, V> fromStreams<V>(List<Stream<V>> streams) {
    var collector = Aggragate<int, V>();
    StreamGroup.merge(streams.asMap().entries.map(
            (entry) => entry.value.map((event) => MapEntry(entry.key, event))))
        .forEach(collector.add);
    return collector;
  }

  @override
  void dispose() {
    disposeProcessor();
    disposeState();
  }
}

/// The `Merge` class is used to merge multiple streams into a single stream.
/// It provides a way to combine multiple sources of data into a single stream of events.
class Merge<T> extends Stream<T>
    with
        Input<T>,
        Output,
        InputCounter,
        OutputCounter,
        Passthrough,
        Waiter,
        InputLogger {
  Merge({List<LogConfig<T>>? loggers}) {
    if (kDebugMode && loggers != null) loggers.forEach(inputLogger);
    initInputCounter();
    initOutputCounter();
    initWaiter(initPassthrough());
  }

  final FutureGroup<void> _blockers = FutureGroup<void>();

  /// Adds a new source stream to the `Merge` instance.
  /// You can specify whether the source should be blocking and whether to wait for the current blocking sources to complete.
  Future<void> addSource(Stream<T> source,
      {bool blocking = false, bool wait = true}) async {
    if (blocking) {
      if (wait && !_blockers.isIdle) await _blockers.onIdle.first;
      _blockers.add(inputStream.addStream(source));
    } else {
      addStream(source);
    }
  }

  /// Creates a new `Merge` instance from a list of input streams.
  static Merge<T> fromList<T>(Iterable<Stream<T>> inputs) {
    var instance = Merge<T>();
    inputs.forEach(instance.addSource);
    return instance;
  }
}

/// The `GroupBy` class is used to group elements of a stream based on a key generated by a provided function.
/// It maintains a map of keys to lists of values, allowing you to easily group and access elements.
class GroupBy<K, V> extends Stream<Map<K, List<V>>>
    with
        Input<V>,
        Output,
        InputCounter,
        InputLogger,
        ValueCache<Map<K, List<V>>>,
        CacheOutput,
        Waiter {
  final Stream<K> Function(V e) builder;
  GroupBy({List<LogConfig<V>>? loggers, required this.builder}) {
    if (kDebugMode && loggers != null) loggers.forEach(inputLogger);
    initInputCounter();
    initCacheOutput();
    initWaiter(_merger.listen(outputStream.add));
    initGroupBy();
  }

  final Merge<Map<K, List<V>>> _merger = Merge();

  final Map<K, List<V>> _state = {};
  final Map<V, K> _reverseLookupTable = {};
  final Map<K, V> _lookupTable = {};

  void initGroupBy() =>
      inputStream.stream.map(_builderStream).forEach(_merger.addSource);

  final Map<V, Stream<K>> _streams = {};
  Stream<Map<K, List<V>>> _builderStream(V obj) {
    if (_streams.containsKey(obj)) return const Stream.empty();
    return builder(obj)
        .expand((key) => _diffEntries(key, obj))
        .map(_apply)
        .map((_) => _state);
  }

  Iterable<MapEntry<K, V?>> _diffEntries(K key, V value) sync* {
    if (_reverseLookupTable.containsKey(value)) {
      yield MapEntry(_reverseLookupTable[value] as K, null);
    }
    yield MapEntry(key, value);
  }

  void _apply(MapEntry<K, V?> entry) {
    _state.putIfAbsent(entry.key, () => []);
    if (entry.value == null) {
      var value = _lookupTable[entry.key];
      if (value == null) throw StateError('Index is missing. ${entry.key}');
      _state[entry.key]!.remove(value);
      _lookupTable.remove(entry.key);
      _reverseLookupTable.remove(value);
    } else {
      _state[entry.key]!.add(entry.value as V);
      _lookupTable[entry.key] = entry.value as V;
      _reverseLookupTable[entry.value!] = entry.key;
    }
  }

  static GroupBy<int, V> fromList<V>(
      List<V> input, Stream<int> Function(V e) builder) {
    var instance = GroupBy(builder: builder);
    instance.addStream(Stream.fromIterable(input));
    return instance;
  }

  static Stream<GroupBy<int, V>> fromLists<V>(
          Stream<List<V>> inputs, Stream<int> Function(V e) builder) =>
      inputs.map((input) => fromList(input, builder));
}
